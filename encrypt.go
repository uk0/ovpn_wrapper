// encrypt.go
// 用法： go run encrypt.go -in client.ovpn -out config_blob.go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"flag"
	"fmt"
	"io/ioutil"
	"os"

	"golang.org/x/crypto/argon2"
)

func deriveKey(password []byte, salt []byte) []byte {
	// Argon2id params - 可按需求调整（时间、内存KB、threads）
	time := uint32(1)
	memory := uint32(64 * 1024) // 64MB
	threads := uint8(4)
	keyLen := uint32(32)
	return argon2.IDKey(password, salt, time, memory, threads, keyLen)
}

func encrypt(plaintext, password []byte) ([]byte, error) {
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return nil, err
	}
	key := deriveKey(password, salt)

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	nonce := make([]byte, aesgcm.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return nil, err
	}
	ciphertext := aesgcm.Seal(nil, nonce, plaintext, nil)

	// 格式： salt || nonce || ciphertext
	out := make([]byte, 0, len(salt)+len(nonce)+len(ciphertext))
	out = append(out, salt...)
	out = append(out, nonce...)
	out = append(out, ciphertext...)

	// 清理 key
	for i := range key {
		key[i] = 0
	}
	return out, nil
}

func toGoByteArray(b []byte) string {
	// produce 0x12,0x34,... lines
	s := ""
	for i, v := range b {
		if i%12 == 0 {
			s += "\n\t"
		}
		s += fmt.Sprintf("0x%02x,", v)
	}
	return s
}

func main() {
	in := flag.String("in", "", "input plaintext config file")
	out := flag.String("out", "config_blob.go", "output go file (will contain var EncryptedConfig = []byte{...})")
	pass := flag.String("pass", "", "password (optional - if not provided will prompt)")
	flag.Parse()

	if *in == "" {
		fmt.Fprintln(os.Stderr, "missing -in")
		os.Exit(2)
	}

	plain, err := ioutil.ReadFile(*in)
	if err != nil {
		fmt.Fprintln(os.Stderr, "read error:", err)
		os.Exit(2)
	}

	var password []byte
	if *pass != "" {
		password = []byte(*pass)
	} else {
		// prompt
		fmt.Print("Enter passphrase: ")
		var p string
		fmt.Scanln(&p)
		password = []byte(p)
	}

	blob, err := encrypt(plain, password)
	if err != nil {
		fmt.Fprintln(os.Stderr, "encrypt error:", err)
		os.Exit(2)
	}

	// generate go file
	f, err := os.OpenFile(*out, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Fprintln(os.Stderr, "write error:", err)
		os.Exit(2)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by encrypt.go - do NOT edit.\npackage main\n\n// EncryptedConfig is the encrypted blob: salt(16) || nonce(12) || ciphertext\nvar EncryptedConfig = []byte{%s\n}\n", toGoByteArray(blob))

	fmt.Printf("Wrote %s (len=%d bytes)\n", *out, len(blob))

	// best-effort cleanup
	for i := range plain {
		plain[i] = 0
	}
	for i := range password {
		password[i] = 0
	}
}
